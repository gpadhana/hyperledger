# Peers

A fundamental element of a Hyderledger Fabric blockchain network is the set of
*peer nodes* (or, simply, *peers*). Peers are fundamental because they manage host
ledgers and smart contracts. In Hyperledger Fabric v2.4, gateway peers also manage
transaction proposal and endorsement. Recall that a ledger immutably records all of the  
transactions generated by smart contracts (which in Hyperledger Fabric are contained
in *chaincode*, more on this later) and endorsed by the required organizations.
Smart contracts and ledgers encapsulate the *processes* and *information*, respectively,
that are shared by channel peers. These aspects of peers make them a good starting
point for understanding a Fabric network.

Besides peers, other elements of a Fabric blockchain network are also important: ledgers
and smart contracts, orderers, endorsement policies, channels, client applications, organizations,
identities, and membership, which you can read about in their own dedicated sections.
This section focuses on peers, and their relationships to these other elements in a Fabric
network.

Figure 1. Example Blockchain Network

![Peer1](./peers.diagram.1.png)

*A blockchain network (Figure 1) is comprised of peers (non-ordering nodes), each
of which stores copies of both ledgers and smart contracts. In this example, the Fabric
network N consists of peers P1, P2 and P3, each of which maintains its own instance of
the distributed ledger L1. P1, P2 and P3 each invoke the same chaincode, S1,
to access their respective copies of the distributed, shared ledger.*

Peers are a flexible and redundant element which can be created, started,
stopped, reconfigured and deleted. Peers expose a set of APIs that enable administrators
and client applications to interact with the services that peers provide. We'll
learn more about these services in this section.

## Fabric Gateway service

Starting in Hyperledger Fabric v2.4, the [Fabric Gateway](../gateway.html) service
is installed and enabled on each peer by default. This gateway service embeds  
the transaction proposal and endorsement logic in the peer, as opposed to in client
applications (in Fabric v2.3 and earlier). The v2.4 client SDKs (Go, Node, Java)
incorporate this peer-centric model of transaction processing, enabling
simplified application development. To continue running v2.3 or earlier client
applications on a gateway peer, simply disable the Fabric Gateway service on that peer.

## Chaincode terminology

Fabric implements **smart contracts** through a type of logic called **chaincode**
--- code that accesses the ledger --- and is written using the Go, Java or Node SDK.
In this topic, we use the term **chaincode**, but feel free to interpret chaincode
as a **smart contract** if that concept is more familiar. To learn more about
chaincode and smart contracts, check out the [documentation on smart contracts
and chaincode](../smartcontract/smartcontract.html).

## Ledgers and Chaincode

Now let's look at a gateway peer in a little more detail. We can see that it's the
peer that hosts both the ledger and chaincode, in addition to services such as
Fabric Gateway. More precisely, the peer actually hosts *instances* of the ledger,
and *instances* of chaincode, because blockchain requires consistent replicas of
data and smart contracts across peers in a channel. This design provides a deliberate
redundancy in a Fabric network --- it avoids single points of failure and provides
consistent, current ledgers. We'll learn more about the distributed and decentralized
nature of a blockchain network later in this section.

Figure 2. Ledgers and Chaincodes

![Peer2](./peers.diagram.2.png)

*A peer hosts instances of ledgers and instances of chaincodes (Figure 2). In
this example, P1 hosts an instance of ledger L1 and an instance of chaincode S1.
There can be many ledgers and chaincodes hosted on any individual peer.*

Because a peer is a *host* for ledgers, chaincodes and services, client
applications and administrators must interact with a peer to access these resources.
That's why peers are considered the fundamental building blocks of a Fabric network.
When a peer is first created, it has neither ledgers nor chaincodes. We'll see later
how ledgers get created, and how chaincodes get installed, on peers.

### Multiple Ledgers

A peer is capable of hosting more than one ledger, which is useful because it allows
for a flexible system design where a single peer can belong to multiple channels.
The simplest configuration is for a peer to host a single ledger, and therefore belong
to a single channel, but it is not uncommon for any one peer to host two or more ledgers
and belong to multiple channels.  

Figure 3. Multiple Ledgers

![Peer3](./peers.diagram.3.png)

*A peer hosting multiple ledgers (Figure 3). Peers host one or more ledgers and
chaincode that accesses them. In this example, we can see that the peer P1 hosts ledgers
L1 and L2. Ledger L1 is accessed using chaincode S1. Ledger L2, on the other hand, can
be accessed using either chaincode S1 or S2.*

Chaincodes installed on a peer can query or update (write to) their respective ledgers.
(It's worth mentioning that peers also host special *system chaincodes* that are always
present in a Fabric network.)

### Multiple Chaincodes

There is no fixed relationship between the number of ledgers hosted on a peer and
the number of installed chaincodes that can access a ledger. Any peer can host
multiple chaincodes and multiple ledgers.

Figure 4. Multiple Chaincodes

![Peer4](./peers.diagram.4.png)

*An example of a peer hosting multiple chaincodes (Figure 4). Each ledger can have
many chaincodes which access it. In this example, we can see that peer P1
hosts ledgers L1 and L2, where L1 is accessed by chaincodes S1 and S2, and
L2 is accessed by S1 and S3. We can see that S1 can access both L1 and L2.*

We'll see a little later why the concept of **channels** in Fabric is important
to hosting multiple ledgers and multiple chaincodes on a peer.

## Applications and Peers

We're now going to show how applications interact with peers to access the
ledger. Ledger-query interactions involve a simple dialogue between
an application and a peer; ledger-update (write) interactions are more
involved with additional steps.

A client application connects to the v2.4 Fabric Gateway, through a gateway peer,  
in order to access ledgers and chaincodes. The v2.4 Fabric Software Development Kits
(SDKs) make this easy for programmers --- the APIs enable applications to (through
the gateway) submit transaction proposals, invoke chaincodes, request endorsement,
receive events, and forward endorsed transactions to the ordering service for
validation and commitment to the distributed ledger. (For more detail on the gateway,
refer to the [Fabric Gateway](../gateway.html) overview on v2.4 transaction management
and client SDKs.)

Through a gateway peer connection, applications can run chaincodes to query or
update the ledger. The result of a ledger query transaction are returned with
simple processing, whereas ledger updates (writes) involve a more complex workflow  
between applications, peers and orderers. Let's investigate this ledger update process in
detail.

<!--

Figure 6. Applications and Peers

![Peer6](./peers.diagram.6.png) -->

Peers, in conjunction with orderers, ensure that the ledger is kept consistent
and up-to-date on every peer in a channel. The following sequence describes how
the interactions between a client application, a gateway peer and orderer nodes
produce this result:

1. **Proposal submission** --- The client application (A1) submits a transaction proposal by connecting to gateway peer P1 and invoking chaincode (S1) to query or update the ledger (L1). For ledger updates (writes), A1 must either delegate endorsement to the gateway service or explicitly identify the organizations required for transaction endorsement.
2. **Transaction validation** --- P1 runs chaincode S1 to validate the transaction proposal and returns its response to the client with the proposed ledger update or query result. For a transaction proposal that is not validated successfully by P1, the transaction workflow ends here. For validated transactions (and queries), the process continues.
3. **Endorsement delegation** --- If A1 has delegated transaction endorsement for a ledger update, the gateway service on P1: a) requests endorsement from a peer in its own organization (selecting the available peer with the highest block height, which can be P1); b) reads the set of endorsement policies for the updated keys; and c) forwards the proposal to endorsement peers in the organizations required to endorse this transaction.
4. **Endorsement collection** --- P1 collects the transaction endorsement (or query) results from each organization and returns the proposal response to the client application A1. For ledger queries, the process is now complete. For ledger updates, if the proposal is endorsed, P1 forwards the transaction to the channel ordering service.
5. **Endorsement retries** --- If the transaction proposal is *not* endorsed, the gateway service will attempt retries on peers that would satisfy endorsement for a ledger update (unless private data has been submitted). If the proposal is *not* endorsed due to detection of transient data --- which often contains private data --- P1 returns a request to the client (A1) for explicit specification of the organizations that are members of the private data collection(s). Once A1 is updated and resubmitted in consideration of private data, the gateway repeats the process by requesting endorsement from the specified organizations and collecting the results.
6. **Endorsement failure** --- If the returned endorsements do not satisfy the endorsement policy requirements, P1 returns a failure message to the client and P1 updates its ledger with *only* a record of the failed transaction proposal. For a failed endorsement, no other ledger or state database update occurs on any peer, and the transaction workflow is now complete.
7. **Endorsement success** --- If the returned endorsements satisfy the endorsement policy requirements, P1 submits the transaction to the ordering service. Once the ordering service validates the transaction, P1 returns a transaction envelope with the endorsements to the client for signing.
8. **Transaction signing** --- The client (A1) returns the signed transaction to P1, which forwards the transaction to O1 for commitment to the ledger (along with other transactions which are first ordered and packaged together in blocks for the ledger update.)
9. **Ledger commitment** --- O1 collects transactions from across the channel and packages them into ordered blocks and distributes the blocks to all peers, including P1. P1 (and all other channel peers) validates the transaction before committing it to the ledger (L1). The commit is an immutable update written to the channel ledger, and the world state (the effect of the transaction, such as a change in asset ownership) is also updated on each peer.
10. **Commit event** --- A1 receives a commit status event from P1 with proof of the ledger commit.

### Querying the Ledger

A peer can promptly return the results of a ledger query to the client application,
because the information required to respond to the query is (typically) in the gateway
peer's ledger. By default, the gateway service does not communicate with other peers
to respond to a query. An application can specify for the gateway service to issue
the query on one or more additional peers, to corroborate the initial result or verify
the currency of the result.

### Updating the Ledger

An update transaction starts in the same way as a query transaction, but continues  
with additional processing. Although ledger-update applications also connect to peers to
invoke a chaincode, unlike with ledger-querying applications, an individual peer
cannot perform a ledger update at this time, because other peers must first
agree to the change --- a process called **consensus**. Therefore, peers return
to the application a **proposed** update --- one that this peer would apply
subject to other peers' prior agreement. The first additional step in updating the
ledger step <!-- --- step 4 in Figure 6 --- --> requires that applications send an
appropriate set of matching proposed updates
to the entire network of peers as a transaction for commitment to their
respective ledgers. This is achieved by the application by using an **orderer** to
package transactions into blocks, and distributing them to the entire network of
peers, where they can be verified before being applied to each peer's local copy
of the ledger. As this whole ordering processing takes some time to complete
(seconds), the application is notified asynchronously, as shown in step five.

Later in this section, you'll learn more about the detailed nature of this
ordering process --- and for a really detailed look at this process see the
[Transaction Flow](../txflow.html) topic.

### Fabric Gateway

Hyperledger Fabric v2.4 introduces the Fabric Gateway service to simplify client
application development. Fabric Gateway (the gateway) embeds the logic for
transaction proposals and endorsements in the peers, which interact with each
other as required by the transaction. Updated SDKs (Go, Node, Java) for v2.4
applications are provided.

Before starting with the new SDKs, you should understand the
[Fabric Gateway](../gateway.html) methodology, including the gateway's handling
of the transaction proposal and endorsement process, interactions with the
discovery service, and collection of endorsement policy results. To continue to
use v2.3 and earlier applications in Fabric v2.4, you can simply disable the Fabric
Gateway service on the applicable peers.

## Peers and Channels

Although this section is about peers rather than channels, it's worth spending a
little time understanding how peers interact with each other, and with applications,
via *channels* --- a mechanism by which a set of components within a Fabric blockchain
network can communicate and transact *privately*.

Channel components are typically peer nodes, orderer nodes and applications, and
by joining a channel, they agree to collaborate to collectively share and
manage identical copies of the ledger. Conceptually, you can compare channels
to groups of friends; a person might have several groups of friends, with each
group having different activities they do together. These groups might be totally
separate (a group of work friends as compared to a group of hobby friends), or there
can be some crossover between them. Nevertheless, each group is its own entity,
with adherence to specific rules required for membership. Channels work the same
way; any one peer may belong to several channels and maintain a ledger and chaincodes
specific to each channel. Or a peer may belong to only a single channel, and therefore
have only one set of rules to follow.

![Peer5](./peers.diagram.5.png)

*Channels allow a specific set of applications and peers to communicate with
each other within a blockchain network. In this example, application A can
communicate directly with peers P1 and P2, using channel C. You can think of the
channel as a pathway for communications between particular applications and
peers. (For simplicity, orderers are not shown in this diagram, but must be
present in a functioning network.)*

We see that channels don't exist in the same way that peers do --- it's more
accurate to think of a channel as a logical structure that is formed by a
collection of physical peers. *It is vital to understand this point --- peers
provide the control point for access to, and management of, channels*.

## Peers and Organizations

Now that you understand peers and their relationship to ledgers, chaincodes
and channels, you'll be able to see how multiple organizations come together to
form a blockchain network.

Blockchain networks are administered by a collection of organizations rather
than a single organization. Peers are central to how this kind of distributed
network is built because they are owned by --- and are the network connection points
for --- these organizations.

Figure 7. Organizations and peers

<a name="Peer8"></a>
![Peer8](./peers.diagram.8.png)

*Figure 8 shows organizations and their peers in a Fabric blockchain network. In
this example, we see four organizations contributing a total of eight peers to form
a network. Channel C connects five of these peers in the network N --- P1, P3,
P5, P7 and P8. The other peers owned by these organizations have not joined
channel C, but typically join at least one other channel. Applications
developed by an organization connect to peers in the same organization
as well as peers in other organizations on a channel. For simplicity, orderer
nodes are not shown in the diagram.*

It's important to notice what's happens during the formation of a Fabric
blockchain network. *The network is both formed and managed by the multiple
organizations that contribute resources to it.* Peers are the resources that
we're discussing in this topic, but organizations also provide other resources,
such as chaincode and consensus algorithms. There's a principle at work here --- the network literally
does not exist without organizations contributing their individual resources to
the collective network. Moreover, the network grows with the resources that
are provided by collaborating organizations, increasing the resiliency and
and security of the network.

You can see that (other than the ordering service) there are no centralized
resources --- in [Figure 8](#Peer8), the network, **N**, would not exist
if the organizations did not contribute their peers and other resources.
Moreover, the network does not depend on any individual organization --- it
can continue to exist as long as its membership meets the management and security
requirements of the network. This is at the heart of what it means
for a network to be decentralized; all of its member organizations share and
contribute equally.

Applications used by organizations, as in [Figure 8](#Peer8), may or may not be
the same, because each organization can decide how it wants to process the ledger.
Both application and presentation logic can therefore vary across organizations,
even though all peers host an equivalent copy of the ledger.

Applications can connect to peers in their organization, or to peers in other
organizations, depending on the nature of the ledger interaction that's required.
For ledger-query interactions, applications may connect only to their own
organization's peers. For ledger-updates, however, a gateway peer connects the
application to peers in *every* organization required to endorse the ledger update
(write) transaction.

## Peers and Identity

Now that you've seen how peers from different organizations come together to
form a blockchain network, it's worth spending a few moments understanding how
peers get assigned to organizations by their administrators.

Peers have an identity assigned to them via a digital certificate from a
particular certificate authority. You can read a lot more about how X.509
digital certificates work elsewhere in this guide but, for now, think of a
digital certificate as like an ID card that provides verifiable
information about a peer. *Each and every peer in the network is assigned a
digital certificate by an administrator from its owning organization*.

Figure 9. Peers and identity

![Peer9](./peers.diagram.9.png)

*When a peer connects to a channel, its digital certificate identifies its
owning organization via a channel MSP. In this example (Figure 9), P1 and P2
have identities issued by CA1. Channel C determines from a policy in its channel
configuration that identities from CA1 should be associated with Org1 using
ORG1.MSP. Similarly, P3 and P4 are identified by ORG2.MSP as part of
Org2.*

Whenever a peer connects to a Fabric network channel, *a policy in
the channel configuration uses the peer's identity to determine its
rights.* The mapping of identity to organization is provided by a component
called a *Membership Service Provider* (MSP) --- which determines how a peer gets
assigned to a specific role in a particular organization and accordingly gains
appropriate access to resources. Moreover, a peer can be owned only
by a single organization, and is therefore associated with a single MSP. We'll
learn more about peer access control later in this section, and there's an entire
section on MSPs and access control policies elsewhere in this guide. But for now,
think of an MSP as providing linkage between an individual identity and a
particular organizational role in a blockchain network.

To digress for a moment, peers as well as *everything that interacts with a
Fabric blockchain network acquire their organizational identity from their digital
certificate and an MSP*. Peers, applications, end users, administrators and
orderers must each have an identity and an associated MSP to interact
with the network. *We give a name to every entity that interacts with
a blockchain network using an identity --- a principal.* You can learn lots
more about principals and organizations elsewhere in this guide, but for now
you know more than enough to continue your understanding of peers.

Finally, note that it's not really important where the peer is physically
located --- it could reside in the cloud, or in a data center owned by one
of the organizations, or on a local machine --- it's the digital certificate
associated with it that identifies it as owned by a particular organization.
In our example above, P3 could be hosted in Org1's data center, but as long as the
digital certificate associated with it is issued by CA2, then it's owned by
Org2.

## Peers and Orderers

We've seen that peers form the basis for a blockchain network, hosting ledgers
and smart contracts which can be queried and updated by peer-connected applications.
However, the mechanism by which applications and peers interact with each other
to ensure that every peer's ledger is kept consistent with each other is mediated
by special nodes called *orderers*, and it's to these nodes we now turn our
attention.

An update transaction is quite different from a query transaction because a single
peer cannot, on its own, update the ledger --- updating requires the consent of other
peers in the network. A peer requires other peers in the network to approve a
ledger update before it can be applied to a peer's local ledger. This process is
called *consensus*, which takes much longer to complete than a simple query. But when
all the peers required to approve the transaction do so, and the transaction is
committed to the ledger, peers will notify their connected applications that the
ledger has been updated. You're about to be shown a lot more detail about how
peers and orderers manage the consensus process in this section.

Specifically, client applications that request a ledger update are involved in a
3-phase process which, through the Fabric Gateway service in v2.4, ensures that all  
peers in the blockchain network keep their ledgers consistent with each other:

1. In the first phase, the client application sends a transaction proposal to a
gateway peer, preferably in its own organization. Assuming the application has
delegated transaction endorsement to the Fabric Gateway service, the gateway peer
validates (runs) the transaction and forwards it to endorsing peers in the organizations
required to satisfy the endorsement policy. These peers also validate the transaction
and return the endorsement results to the gateway peer, without updating their ledgers.
2. In the second phase, the gateway peer collects the endorsement results from
the peers and packages them into blocks. If endorsed, the gateway service sends the
transaction to the client application for signing, which signs and returns it
to the gateway peer.
3. In the third and final phase, the signed transaction (blocks) are distributed
to the endorsing peers, which validate the transaction.

In addition to the client application and gateway peers, orderer nodes play a
critical role in transactions that update the ledger. Before committing transactions
to the ledger, orderer nodes do just that --- they order all submitted transactions
to ensure a consistent and accurate sequence of transactions on the shared ledger.
Note that blockchain manages inconsistent ledgers through a process called forking,
and the subsequent pruning (discarding and archiving) of the invalidated forks.

### Phase 1: Proposal

Phase 1 of the transaction workflow involves an interaction between a client
application and a set of peers --- orderers are not involved yet. In Phase 1,
the client application initiates a request to endorsing peers, through the
Fabric Gateway service, to return their responses to the proposed transaction.

To begin phase 1, the client application generates a transaction proposal and
sends it to a gateway peer in its own organization. The gateway peer with
the highest block height is selected; if none are discovered, the gateway
service moves on to select a gateway peer in another organization.

Once selected, the gateway peer validates the transaction by invoking the
chaincode without a ledger update --- this can be referred to as simulating
the transaction, because it runs the application without any effect on the ledger
or state on any peer. The gateway peer then returns it transaction result to the
client, and if the application delegates endorsement to the gateway service,
it also forwards the proposal to the *endorsing peers*.

Each endorsing peer then follows suit, executing the chaincode called by the
client application to generate a transaction proposal response and return it
(signed) to the gateway peer. The gateway peer collects all responses, and if
the responses collectively satisfy the endorsement policy (or policies), it
forwards the transaction to the ordering service for sequencing. If the
endorsement policies are not satisfied, or if the transaction would write to
a private data collection, the gateway peer returns a failed proposal message
to the client. The client then must explicitly specify the organizations
required for endorsement and resubmit the updated transaction proposal.

<!--

. Once the
application has received a sufficient number of signed proposal responses,
the first phase of the transaction flow is complete. Let's examine this phase in
a little more detail.

![Peer10](./peers.diagram.10.png)

*Transaction proposals are independently executed by peers who return endorsed
proposal responses. In this example, application A1 generates transaction T1
proposal P which it sends to both peer P1 and peer P2 on channel C. P1 executes
S1 using transaction T1 proposal P generating transaction T1 response R1 which
it endorses with E1. Independently, P2 executes S1 using transaction T1
proposal P generating transaction T1 response R2 which it endorses with E2.
Application A1 receives two endorsed responses for transaction T1, namely E1
and E2.*

-->

<!--
Initially, a set of peers are chosen by the application to generate a set of
proposed ledger updates. Which peers are chosen by the application? Well, that
depends on the *endorsement policy* (defined for a chaincode), which defines
the set of organizations that need to endorse a proposed ledger change before it
can be accepted by the network. This is literally what it means to achieve
consensus --- every organization who matters must have endorsed the proposed
ledger change *before* it will be accepted onto any peer's ledger.

-->

<!--

A peer endorses a proposal response by adding its digital signature, and signing
the entire payload using its private key. This endorsement can be subsequently
used to prove that this organization's peer generated a particular response. In
our example, if peer P1 is owned by organization Org1, endorsement E1
corresponds to a digital proof that "Transaction T1 response R1 on ledger L1 has
been provided by Org1's peer P1!".

-->

Phase 1 is complete for a successful ledger update proposal when the client
application receives signed responses from the gateway service that satisfies
the endorsement polic. Note that endorsement peers can return different and
therefore inconsistent transaction proposal responses. This variation can be
caused by peers running the transaction at different times with ledgers in
varying states of being updated, in which case the application can simply
request another response to the proposal. Less likely, but much more seriously,
results of a transaction may vary because the invoked chaincode is *non-deterministic*.
Non-deterministic chaincode is code that produces different results over time
for the same transaction, indicating a problem with the chaincode's reliability.
By design, blockchain prohibits inconsistent results from being written to the
ledger, regardless of the cause.

<!-- (Strictly
speaking, even this is not enough; this discussion continues in the transaction
section where non-determinism is discussed in more detail.)

target section or discussion not found -->

An individual peer cannot detect whether its transaction result is
non-deterministic --- transaction responses must be collected by the gateway
service for comparison before it can detect non-determinism in chaincode.
In response to inconsistent transaction responses, caused either by
nondeterministic chaincode or any other issue, the gateway service terminates
the transaction workflow and returns a failed proposal message to the client. The
client can then resubmit the transaction proposal or an amended transaction proposal.

If the transaction proposal is endorsed, at the end of phase 1, the gateway service
returns a successful proposal message to the client and submits the transaction to
the ordering service, as described next in phase 2.

### Phase 2: Ordering and packaging transactions into blocks

The second phase of the transaction workflow is the ordering and packaging phase. The
ordering service (orderer nodes) receives transactions containing signed and endorsed
proposal responses, from one or more applications via the gateway service, and orders
and packages the transactions into blocks. For details about the ordering and packaging
phase, see the [conceptual information about the ordering phase](../orderer/ordering_service.html#phase-two-ordering-and-packaging-transactions-into-blocks).

### Phase 3: Validation and commit

At the end of phase 2, we see that orderers are responsible for the simple
but vital processes of ordering endorsed transactions forwarded by the gateway
service and packaging them into blocks for distribution to the peers.

The final phase of the transaction workflow involves the distribution (and
subsequent validation) of blocks from the orderer to the peers, where they are
committed to the ledger. Specifically, at each peer, every transaction within a
block is validated to ensure that it has been consistently endorsed by all
relevant organizations before being committed to the ledger. A different
validation result across on any peers means endorsements by one or more of  
those peers are not equivalent. Failed transactions are retained for audit,
but are not committed to the ledger.

Figure 12. Orderers and blocks

![Peer12](./peers.diagram.12.png)

*The second role of an orderer node is to distribute blocks to peers. In this
example (Figure 12), orderer O1 distributes block B2 to peer P1 and peer P2. Peer P1
processes block B2, resulting in a new block being added to ledger L1 on P1.
In parallel, peer P2 processes block B2, resulting in a new block being added
to ledger L1 on P2. Once this process is complete, the ledger L1 has been
consistently updated on peers P1 and P2, and each may inform connected
applications that the transaction has been processed.*

Phase 3 begins with the orderer distributing blocks to all peers connected to
it. Peers are connected to orderers on channels such that when a new block is
generated, all of the peers connected to the orderer will be sent a copy of the
new block. Each peer will process this block independently, but in exactly the
same way as every other peer on the channel. In this way, we'll see that the
ledger can be kept consistent. It's also worth noting that not every peer needs
to be connected to an orderer --- peers can cascade blocks to other peers using
the **gossip** protocol, who also can process them independently. But let's
leave that discussion to another time!

Upon receipt of a block, a peer will process each transaction in the sequence in
which it appears in the block. For every transaction, each peer will verify that
the transaction has been endorsed by the required organizations according to the
*endorsement policy* of the chaincode which generated the transaction. For
example, some transactions may only need to be endorsed by a single
organization, whereas others may require multiple endorsements before they are
considered valid. This process of validation verifies that all relevant
organizations have generated the same outcome or result. Also note that this
validation is different than the endorsement check in phase 1, where it is the
application that receives the response from endorsing peers and makes the
decision to send the proposal transactions. In case the application violates
the endorsement policy by sending wrong transactions, the peer is still able to
reject the transaction in the validation process of phase 3.

If a transaction has been endorsed correctly, the peer will attempt to apply it
to the ledger. To do this, a peer must perform a ledger consistency check to
verify that the current state of the ledger is compatible with the state of the
ledger when the proposed update was generated. This may not always be possible,
even when the transaction has been fully endorsed. For example, another
transaction may have updated the same asset in the ledger such that the
transaction update is no longer valid and therefore can no longer be applied. In
this way, the ledger is kept consistent across each peer in the channel because
they each follow the same rules for validation.

After a peer has successfully validated each individual transaction, it updates
the ledger. Failed transactions are not applied to the ledger, but they are
retained for audit purposes, as are successful transactions. This means that
peer blocks are almost exactly the same as the blocks received from the orderer,
except for a valid or invalid indicator on each transaction in the block.

We also note that phase 3 does not require the running of chaincodes --- this is
done only during phase 1, and that's important. It means that chaincodes only have
to be available on endorsing nodes, rather than throughout the blockchain
network. This is often helpful as it keeps the logic of the chaincode
confidential to endorsing organizations. This is in contrast to the output of
the chaincodes (the transaction proposal responses) which are shared with every
peer in the channel, whether or not they endorsed the transaction. This
specialization of endorsing peers is designed to help scalability and confidentiality.

Finally, every time a block is committed to a peer's ledger, that peer
generates an appropriate *event*. *Block events* include the full block content,
while *block transaction events* include summary information only, such as
whether each transaction in the block has been validated or invalidated.
*Chaincode* events that the chaincode execution has produced can also be
published at this time. Applications can register for these event types so
that they can be notified when they occur. These notifications conclude the
third and final phase of the transaction workflow.

In summary, phase 3 sees the blocks which are generated by the orderer
consistently applied to the ledger. The strict ordering of transactions into
blocks allows each peer to validate that transaction updates are consistently
applied across the blockchain network.

### Orderers and Consensus

This entire transaction workflow process is called *consensus*, because all peers
have to reach agreement on the order and content of transactions, in a process
that is mediated by orderers. Consensus is a multi-step process and ledger updates
only occur when the process completes successfully --- which can happen at slightly
different times on different peers. Think of the orderers as nodes which collect,
sequence and distribute proposed ledger updates for peers to endorse and add  
to the ledger.

That's it! We've now finished our tour of peers and their interactions with other
Fabric components, such as client applications, chaincodes and orderers. We've seen
that peers are in many ways the most fundamental element of Hyperledger Fabric
architecture --- they form the network, host chaincodes and the ledger, handle
transaction proposals and responses, and keep the ledger updated with validated
and endorsed transactions.

<!--- Licensed under Creative Commons Attribution 4.0 International License
https://creativecommons.org/licenses/by/4.0/) -->
