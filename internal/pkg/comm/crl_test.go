/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package comm_test

import (
	"crypto/ecdsa"
	"crypto/rand"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/base64"
	"encoding/pem"
	"testing"
	"time"

	"github.com/hyperledger/fabric/common/crypto/tlsgen"
	"github.com/hyperledger/fabric/internal/pkg/comm"
	"github.com/pkg/errors"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

var (
	// All certificates and keys generated by tlsgen.NewCA()
	// We don't invoke it directly because we cannot extract
	// the private key via the API.
	caCertPEM = `-----BEGIN CERTIFICATE-----
MIIBvzCCAWWgAwIBAgIQA5AeweClz89snTwybkjDOzAKBggqhkjOPQQDAjAwMS4w
LAYDVQQFEyU0NzM1OTk4NTY3ODMyMzMzOTE2NzMxODUxMDIxMTE5NzAxODE5MB4X
DTIwMDgyNzE4NDUyOVoXDTMwMDgyNjE4NDUyOVowMDEuMCwGA1UEBRMlNDczNTk5
ODU2NzgzMjMzMzkxNjczMTg1MTAyMTExOTcwMTgxOTBZMBMGByqGSM49AgEGCCqG
SM49AwEHA0IABNuJViCR9V563eIiRnPJDFxES65ebxdNe4W5JvqvDimx0UnmwWwM
02i2pvsjfg9+XTUmz0ju2ZFgf73HR5HUd9GjYTBfMA4GA1UdDwEB/wQEAwIBpjAd
BgNVHSUEFjAUBggrBgEFBQcDAgYIKwYBBQUHAwEwDwYDVR0TAQH/BAUwAwEB/zAd
BgNVHQ4EFgQU4CnSYBfVKyIvyC8UD3Cg+UvCIH0wCgYIKoZIzj0EAwIDSAAwRQIg
TfOwaOjRg5VTur6XIqq32R96l/1J1WgaqnfqpvpqWF8CIQCajffNpISKjfIBECfc
pId7M7/dClf/SlSQu22iUoo9Og==
-----END CERTIFICATE-----`

	caKeyPEM = base64ToPEM(`LS0tLS1CRUdJTiBFQyBQUklWQVRFIEtFWS0tLS0tCk1JR0hBZ0VBTUJ
NR0J5cUdTTTQ5QWdFR0NDcUdTTTQ5QXdFSEJHMHdhd0lCQVFRZ05EMEw3SU5nNlh6OE9FbmsKdTVRWG15TERBb2hJMC9k
eXgvSWFYWkhXWEdtaFJBTkNBQVRiaVZZZ2tmVmVldDNpSWtaenlReGNSRXV1WG04WApUWHVGdVNiNnJ3NHBzZEZKNXNGc
0ROTm90cWI3STM0UGZsMDFKczlJN3RtUllIKzl4MGVSMUhmUgotLS0tLUVORCBFQyBQUklWQVRFIEtFWS0tLS0t`)

	revokedCertPEM = `-----BEGIN CERTIFICATE-----
MIIBqDCCAU+gAwIBAgIRANJFWzCo88fU/UtBB0RkmykwCgYIKoZIzj0EAwIwMDEu
MCwGA1UEBRMlNDczNTk5ODU2NzgzMjMzMzkxNjczMTg1MTAyMTExOTcwMTgxOTAe
Fw0yMDA4MjcxODQ1MjlaFw00MDA4MjMxODQ1MjlaMDIxMDAuBgNVBAUTJzI3OTQ5
Nzk5NzE1MjU4NTE2MzcwNjkwODc4NTEzMDkyMTU2NDk2OTBZMBMGByqGSM49AgEG
CCqGSM49AwEHA0IABJLMKSxJ/e8+bPwT05UO+kISeBz+6IsRsbtkn/jAqHGvdKdO
mjyqHbhBgHnRT8kkYryGaeRnjIBKYxIpr7Ws/FqjSDBGMA4GA1UdDwEB/wQEAwIF
oDATBgNVHSUEDDAKBggrBgEFBQcDAjAfBgNVHSMEGDAWgBTgKdJgF9UrIi/ILxQP
cKD5S8IgfTAKBggqhkjOPQQDAgNHADBEAiB53Bs9UZrw8aMlNhEYo+hgmUGstSjN
+XGbXxWQ7QarnQIgAQ6ZKxc9Q6o/lyPnbGC+u1Z5CHQxIH87OWxSodLyHSs=
-----END CERTIFICATE-----`

	revokedKeyBase64PEM = base64ToPEM(`LS0tLS1CRUdJTiBFQyBQUklWQVRFIEtFWS0tLS0tCk1JR0hBZ
0VBTUJNR0J5cUdTTTQ5QWdFR0NDcUdTTTQ5QXdFSEJHMHdhd0lCQVFRZ0tNSDl1MS8rQUt6TEtTMEQKNzdkQThRaFBEWlBiemt
xMWFqcUVGYVJzMU5PaFJBTkNBQVNTekNrc1NmM3ZQbXo4RTlPVkR2cENFbmdjL3VpTApFYkc3WkovNHdLaHhyM1NuVHBvOHFoM
jRRWUI1MFUvSkpHSzhobW5rWjR5QVNtTVNLYSsxclB4YQotLS0tLUVORCBFQyBQUklWQVRFIEtFWS0tLS0t`)

	notRevokedCertPEM = `-----BEGIN CERTIFICATE-----
MIIBpzCCAU2gAwIBAgIQJXN7xV3K/Cm4/1PKuNzDgTAKBggqhkjOPQQDAjAwMS4w
LAYDVQQFEyU0NzM1OTk4NTY3ODMyMzMzOTE2NzMxODUxMDIxMTE5NzAxODE5MB4X
DTIwMDgyNzE4NDUyOVoXDTQwMDgyMzE4NDUyOVowMTEvMC0GA1UEBRMmNDk3ODEw
NjAzNTYxMzAxNTY2NzUyMDY0MjE5NTc4NzAxNDIzMzcwWTATBgcqhkjOPQIBBggq
hkjOPQMBBwNCAARuIS9JBweJsrSC/m8b8UrEB7jQEDRbTUUJfrGh6S4CMKHPiRAa
x/0wOCKGmEt92Yls/D26vHsCrvBYBXAbyTL3o0gwRjAOBgNVHQ8BAf8EBAMCBaAw
EwYDVR0lBAwwCgYIKwYBBQUHAwIwHwYDVR0jBBgwFoAU4CnSYBfVKyIvyC8UD3Cg
+UvCIH0wCgYIKoZIzj0EAwIDSAAwRQIgGeDMIGwFzfemvCqK+tbev5H4ex3ya0Lc
xLKf0dSsPgwCIQCoYp987tTr1PNkWARWfI8i7tWlqNFbh07Uquy8dAB61Q==
-----END CERTIFICATE-----`

	notRevokedKeyPEM = base64ToPEM(`LS0tLS1CRUdJTiBFQyBQUklWQVRFIEtFWS0tLS0tCk1JR0hBZ0VBTUJN
R0J5cUdTTTQ5QWdFR0NDcUdTTTQ5QXdFSEJHMHdhd0lCQVFRZ2poTkFEOGVRekNXempsYUwKZUJVMzN2ZVo1Wm9xaUNhMU1jeTNpdV
BsY1RtaFJBTkNBQVJ1SVM5SkJ3ZUpzclNDL204YjhVckVCN2pRRURSYgpUVVVKZnJHaDZTNENNS0hQaVJBYXgvMHdPQ0tHbUV0OTJZ
bHMvRDI2dkhzQ3J2QllCWEFieVRMMwotLS0tLUVORCBFQyBQUklWQVRFIEtFWS0tLS0t`)
)

func TestTLSRevocation(t *testing.T) {
	t.Parallel()

	serverCA, err := tlsgen.NewCA()
	require.NoError(t, err)

	serverCertKeyPair, err := serverCA.NewServerCertKeyPair("127.0.0.1")
	require.NoError(t, err)

	probeTLS := func(endpoint string, certificate, key []byte) error {
		cert, err := tls.X509KeyPair(certificate, key)
		if err != nil {
			return err
		}

		tlsCfg := &tls.Config{
			Certificates: []tls.Certificate{cert},
			RootCAs:      x509.NewCertPool(),
			MinVersion:   tls.VersionTLS12,
			MaxVersion:   tls.VersionTLS12,
		}

		tlsCfg.RootCAs.AppendCertsFromPEM(serverCA.CertBytes())

		conn, err := tls.Dial("tcp", endpoint, tlsCfg)
		if err != nil {
			return err
		}
		conn.Close()
		return nil
	}

	revokedCerts := createRevokedCertificates(t, []byte(caCertPEM), []byte(caKeyPEM), []byte(revokedCertPEM))

	gRPCServer, err := comm.NewGRPCServer("127.0.0.1:", comm.ServerConfig{
		SecOpts: comm.SecureOptions{
			ClientRootCAs:     [][]byte{[]byte(caCertPEM)},
			Key:               serverCertKeyPair.Key,
			Certificate:       serverCertKeyPair.Cert,
			UseTLS:            true,
			RequireClientCert: true,
			VerifyCertificate: func(rawCerts [][]byte, _ [][]*x509.Certificate) error {
				cert, err := x509.ParseCertificate(rawCerts[0])
				require.NoError(t, err)

				if revokedCerts.Revoked(cert) {
					return errors.Errorf("certificate is revoked")
				}

				return nil
			},
		},
	})
	go gRPCServer.Start()
	defer gRPCServer.Stop()

	err = probeTLS(gRPCServer.Address(), []byte(revokedCertPEM), []byte(revokedKeyBase64PEM))
	require.EqualError(t, err, "remote error: tls: bad certificate")

	err = probeTLS(gRPCServer.Address(), []byte(notRevokedCertPEM), []byte(notRevokedKeyPEM))
	require.NoError(t, err)
}

func TestRevokedCertificates(t *testing.T) {
	t.Parallel()

	revokedCert := PEM2Cert(t, []byte(revokedCertPEM))
	notRevokedCert := PEM2Cert(t, []byte(notRevokedCertPEM))

	revokedCerts := createRevokedCertificates(t, []byte(caCertPEM), []byte(caKeyPEM), []byte(revokedCertPEM))

	assert.True(t, revokedCerts.Revoked(revokedCert))
	assert.False(t, revokedCerts.Revoked(notRevokedCert))
}

func createRevokedCertificates(t *testing.T, caCertPEM, caKeyPEM, revokedCertPEM []byte) *comm.RevokedCertificates {
	caCert := PEM2Cert(t, caCertPEM)
	caKey := PEM2Key(t, caKeyPEM)
	revokedCert := PEM2Cert(t, revokedCertPEM)

	crlBytes, err := caCert.CreateCRL(rand.Reader, caKey, []pkix.RevokedCertificate{
		{
			SerialNumber: revokedCert.SerialNumber,
		},
	}, time.Now(), time.Now().Add(time.Hour*24*365*20))
	require.NoError(t, err)

	crls := []comm.IssuedCRL{
		{
			IssuerCertificate: caCertPEM,
			RevocationList:    pem.EncodeToMemory(&pem.Block{Bytes: crlBytes}),
		},
	}

	revokedCerts, err := comm.NewRevokedCertificates(crls)
	require.NoError(t, err)

	return revokedCerts
}

func PEM2Key(t *testing.T, PEM []byte) *ecdsa.PrivateKey {
	key, err := x509.ParsePKCS8PrivateKey(PEM2DER(t, PEM))
	require.NoError(t, err)
	require.NotNil(t, key)
	ecdsaKey, isECDSA := key.(*ecdsa.PrivateKey)
	require.True(t, isECDSA)
	return ecdsaKey
}

func PEM2Cert(t *testing.T, PEM []byte) *x509.Certificate {
	cert, err := x509.ParseCertificate(PEM2DER(t, PEM))
	require.NoError(t, err)
	require.NotNil(t, cert)
	return cert
}

func PEM2DER(t *testing.T, PEM []byte) []byte {
	bl, rest := pem.Decode(PEM)
	require.Empty(t, rest)
	require.NotNil(t, bl)
	return bl.Bytes
}

func base64ToPEM(base64PEM string) []byte {
	pem, err := base64.StdEncoding.DecodeString(base64PEM)
	if err != nil {
		panic(err)
	}
	return pem
}
