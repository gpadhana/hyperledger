// Code generated by protoc-gen-go. DO NOT EDIT.
// source: ccprovider.proto

package ccprovider

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// -------- ChaincodeData is stored on the LSCC -------
// ChaincodeData defines the datastructure for chaincodes to be serialized by proto
// Type provides an additional check by directing to use a specific package after instantiation
// Data is Type specific (see CDSPackage and SignedCDSPackage)
type ChaincodeData struct {
	// Name of the chaincode
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Version of the chaincode
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// Escc for the chaincode instance
	Escc string `protobuf:"bytes,3,opt,name=escc,proto3" json:"escc,omitempty"`
	// Vscc for the chaincode instance
	Vscc string `protobuf:"bytes,4,opt,name=vscc,proto3" json:"vscc,omitempty"`
	// Policy endorsement policy for the chaincode instance
	Policy []byte `protobuf:"bytes,5,opt,name=policy,proto3" json:"policy,omitempty"`
	// Data data specific to the package
	Data []byte `protobuf:"bytes,6,opt,name=data,proto3" json:"data,omitempty"`
	// Id of the chaincode that's the unique fingerprint for the CC This is not
	// currently used anywhere but serves as a good eyecatcher
	Id []byte `protobuf:"bytes,7,opt,name=id,proto3" json:"id,omitempty"`
	// InstantiationPolicy for the chaincode
	InstantiationPolicy  []byte   `protobuf:"bytes,8,opt,name=instantiation_policy,json=instantiationPolicy,proto3" json:"instantiation_policy,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChaincodeData) Reset()         { *m = ChaincodeData{} }
func (m *ChaincodeData) String() string { return proto.CompactTextString(m) }
func (*ChaincodeData) ProtoMessage()    {}
func (*ChaincodeData) Descriptor() ([]byte, []int) {
	return fileDescriptor_c9a74861accd0272, []int{0}
}

func (m *ChaincodeData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ChaincodeData.Unmarshal(m, b)
}
func (m *ChaincodeData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ChaincodeData.Marshal(b, m, deterministic)
}
func (m *ChaincodeData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChaincodeData.Merge(m, src)
}
func (m *ChaincodeData) XXX_Size() int {
	return xxx_messageInfo_ChaincodeData.Size(m)
}
func (m *ChaincodeData) XXX_DiscardUnknown() {
	xxx_messageInfo_ChaincodeData.DiscardUnknown(m)
}

var xxx_messageInfo_ChaincodeData proto.InternalMessageInfo

func (m *ChaincodeData) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ChaincodeData) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ChaincodeData) GetEscc() string {
	if m != nil {
		return m.Escc
	}
	return ""
}

func (m *ChaincodeData) GetVscc() string {
	if m != nil {
		return m.Vscc
	}
	return ""
}

func (m *ChaincodeData) GetPolicy() []byte {
	if m != nil {
		return m.Policy
	}
	return nil
}

func (m *ChaincodeData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ChaincodeData) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *ChaincodeData) GetInstantiationPolicy() []byte {
	if m != nil {
		return m.InstantiationPolicy
	}
	return nil
}

// ----- CDSData ------
// CDSData is data stored in the LSCC on instantiation of a CC
// for CDSPackage.  This needs to be serialized for ChaincodeData
// hence the protobuf format
type CDSData struct {
	// CodeHash hash of CodePackage from ChaincodeDeploymentSpec
	CodeHash []byte `protobuf:"bytes,1,opt,name=code_hash,json=codeHash,proto3" json:"code_hash,omitempty"`
	// MetaDataHash hash of Name and Version from ChaincodeDeploymentSpec
	MetaDataHash         []byte   `protobuf:"bytes,2,opt,name=meta_data_hash,json=metaDataHash,proto3" json:"meta_data_hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CDSData) Reset()         { *m = CDSData{} }
func (m *CDSData) String() string { return proto.CompactTextString(m) }
func (*CDSData) ProtoMessage()    {}
func (*CDSData) Descriptor() ([]byte, []int) {
	return fileDescriptor_c9a74861accd0272, []int{1}
}

func (m *CDSData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CDSData.Unmarshal(m, b)
}
func (m *CDSData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CDSData.Marshal(b, m, deterministic)
}
func (m *CDSData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDSData.Merge(m, src)
}
func (m *CDSData) XXX_Size() int {
	return xxx_messageInfo_CDSData.Size(m)
}
func (m *CDSData) XXX_DiscardUnknown() {
	xxx_messageInfo_CDSData.DiscardUnknown(m)
}

var xxx_messageInfo_CDSData proto.InternalMessageInfo

func (m *CDSData) GetCodeHash() []byte {
	if m != nil {
		return m.CodeHash
	}
	return nil
}

func (m *CDSData) GetMetaDataHash() []byte {
	if m != nil {
		return m.MetaDataHash
	}
	return nil
}

// ----- SignedCDSData ------
// SignedCDSData is data stored in the LSCC on instantiation of a CC
// for SignedCDSPackage. This needs to be serialized for ChaincodeData
// hence the protobuf format
type SignedCDSData struct {
	CodeHash             []byte   `protobuf:"bytes,1,opt,name=code_hash,json=codeHash,proto3" json:"code_hash,omitempty"`
	MetaDataHash         []byte   `protobuf:"bytes,2,opt,name=meta_data_hash,json=metaDataHash,proto3" json:"meta_data_hash,omitempty"`
	SignatureHash        []byte   `protobuf:"bytes,3,opt,name=signature_hash,json=signatureHash,proto3" json:"signature_hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignedCDSData) Reset()         { *m = SignedCDSData{} }
func (m *SignedCDSData) String() string { return proto.CompactTextString(m) }
func (*SignedCDSData) ProtoMessage()    {}
func (*SignedCDSData) Descriptor() ([]byte, []int) {
	return fileDescriptor_c9a74861accd0272, []int{2}
}

func (m *SignedCDSData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SignedCDSData.Unmarshal(m, b)
}
func (m *SignedCDSData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SignedCDSData.Marshal(b, m, deterministic)
}
func (m *SignedCDSData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignedCDSData.Merge(m, src)
}
func (m *SignedCDSData) XXX_Size() int {
	return xxx_messageInfo_SignedCDSData.Size(m)
}
func (m *SignedCDSData) XXX_DiscardUnknown() {
	xxx_messageInfo_SignedCDSData.DiscardUnknown(m)
}

var xxx_messageInfo_SignedCDSData proto.InternalMessageInfo

func (m *SignedCDSData) GetCodeHash() []byte {
	if m != nil {
		return m.CodeHash
	}
	return nil
}

func (m *SignedCDSData) GetMetaDataHash() []byte {
	if m != nil {
		return m.MetaDataHash
	}
	return nil
}

func (m *SignedCDSData) GetSignatureHash() []byte {
	if m != nil {
		return m.SignatureHash
	}
	return nil
}

func init() {
	proto.RegisterType((*ChaincodeData)(nil), "ccprovider.ChaincodeData")
	proto.RegisterType((*CDSData)(nil), "ccprovider.CDSData")
	proto.RegisterType((*SignedCDSData)(nil), "ccprovider.SignedCDSData")
}

func init() { proto.RegisterFile("ccprovider.proto", fileDescriptor_c9a74861accd0272) }

var fileDescriptor_c9a74861accd0272 = []byte{
	// 306 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x91, 0xcf, 0x4a, 0x03, 0x31,
	0x10, 0x87, 0xd9, 0x6d, 0xed, 0x9f, 0xa1, 0x2d, 0x12, 0x45, 0x02, 0x5e, 0x4a, 0x51, 0xe8, 0xa9,
	0x8b, 0x28, 0x3e, 0x80, 0xed, 0xc1, 0x83, 0x07, 0x69, 0x6f, 0x5e, 0xca, 0x34, 0x89, 0xbb, 0x03,
	0xdd, 0x64, 0x49, 0xd2, 0x42, 0xdf, 0xd3, 0x07, 0x92, 0x49, 0xab, 0xc5, 0xbb, 0xb7, 0xdf, 0x7c,
	0xf3, 0x65, 0xc2, 0x30, 0x70, 0xa9, 0x54, 0xe3, 0xdd, 0x9e, 0xb4, 0xf1, 0xb3, 0xc6, 0xbb, 0xe8,
	0x04, 0x9c, 0xc9, 0xe4, 0x2b, 0x83, 0xe1, 0xbc, 0x42, 0xb2, 0xca, 0x69, 0xb3, 0xc0, 0x88, 0x42,
	0x40, 0xdb, 0x62, 0x6d, 0x64, 0x36, 0xce, 0xa6, 0xfd, 0x65, 0xca, 0x42, 0x42, 0x77, 0x6f, 0x7c,
	0x20, 0x67, 0x65, 0x9e, 0xf0, 0x4f, 0xc9, 0xb6, 0x09, 0x4a, 0xc9, 0xd6, 0xd1, 0xe6, 0xcc, 0x6c,
	0xcf, 0xac, 0x7d, 0x64, 0x9c, 0xc5, 0x0d, 0x74, 0x1a, 0xb7, 0x25, 0x75, 0x90, 0x17, 0xe3, 0x6c,
	0x3a, 0x58, 0x9e, 0x2a, 0x76, 0x35, 0x46, 0x94, 0x9d, 0x44, 0x53, 0x16, 0x23, 0xc8, 0x49, 0xcb,
	0x6e, 0x22, 0x39, 0x69, 0xf1, 0x00, 0xd7, 0x64, 0x43, 0x44, 0x1b, 0x09, 0x23, 0x39, 0xbb, 0x3e,
	0x4d, 0xea, 0x25, 0xe3, 0xea, 0x4f, 0xef, 0x3d, 0xb5, 0x26, 0x6f, 0xd0, 0x9d, 0x2f, 0x56, 0x69,
	0x9f, 0x5b, 0xe8, 0xf3, 0x6e, 0xeb, 0x0a, 0x43, 0x95, 0x96, 0x1a, 0x2c, 0x7b, 0x0c, 0x5e, 0x31,
	0x54, 0xe2, 0x0e, 0x46, 0xb5, 0x89, 0xb8, 0xe6, 0x7f, 0x8f, 0x46, 0x9e, 0x8c, 0x01, 0x53, 0x7e,
	0xce, 0xd6, 0xe4, 0x00, 0xc3, 0x15, 0x95, 0xd6, 0xe8, 0xff, 0x9b, 0x29, 0xee, 0x61, 0x14, 0xa8,
	0xb4, 0x18, 0x77, 0xfe, 0x34, 0xa7, 0x95, 0xac, 0xe1, 0x2f, 0x65, 0xed, 0xe5, 0xf9, 0xe3, 0xa9,
	0xa4, 0x58, 0xed, 0x36, 0x33, 0xe5, 0xea, 0xa2, 0x3a, 0x34, 0xc6, 0x6f, 0x8d, 0x2e, 0x8d, 0x2f,
	0x3e, 0x71, 0xe3, 0x49, 0x15, 0xca, 0x79, 0x53, 0x28, 0x57, 0xd7, 0xce, 0x16, 0xe7, 0xbb, 0x6e,
	0x3a, 0xe9, 0xd4, 0x8f, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x36, 0xd1, 0x14, 0xa3, 0xfe, 0x01,
	0x00, 0x00,
}
